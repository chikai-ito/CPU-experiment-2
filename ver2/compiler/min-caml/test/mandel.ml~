let rec print_int x =
  let a = x / 100 in
  let b = (x - a * 100) / 10 in
  let c = (x - a * 100 - b * 10) in
  if a > 0 then (
    print_char (a + 48);
    print_char (b + 48);
    print_char (c + 48)
  ) else (
    if b > 0 then (
      print_char (b + 48);
      print_char (c + 48)
    ) else (
      print_char (c + 48)
    )
  )
in

let limit = 10 (* maximum number of iterations *)
in

let size = 64
in

let rec cadd x y =
  let (rex, imx) = x in
  let (rey, imy) = y in
  (rex +. rey, imx +. imy)
in

let rec cmul x y =
  let (rex, imx) = x in
  let (rey, imy) = y in
  (rex *. rey -. imx *. imy, rex *. imy +. rey *. imx)
in

let rec norm_sqr x =
  let (re, im) = x in
  re *. re +. im *. im
in

let rec set_pixel p a =
  p.(0) <- a; p.(1) <- a; p.(2) <- a
in

let complex_mat = create_array size (create_array size (0.0, 0.0))
in

let rgb = create_array 3 0
in

let image = create_array size (create_array size rgb)
in


let rec init_complex_mat _ =
  let rec malloc i n =
    if i = n then
      ()
    else
      (let row = create_array size (0.0, 0.0) in
       complex_mat.(i) <- row;
       malloc (i+1) n) in
  let rec init_loop i j n =
    let ai = (float_of_int i) /. (float_of_int (n-1)) in
    let aj = (float_of_int j) /. (float_of_int (n-1)) in
    let re = 4.0 *. ai -. 2.0 in
    let im = 4.0 *. aj -. 2.0 in
    if i = n then
      if j = n then
        ()
      else
        (complex_mat.(i).(j) <- (re, im);
         init_loop i (j+1) n)
    else
      if j = n then
        init_loop (i+1) 0 n
      else
        (complex_mat.(i).(j) <- (re, im);
         init_loop i (j+1) n) in
  malloc 0 size;
  init_loop 0 0 size
in


let rec init_image _ =
  let rec malloc_1d i n row =
    if i = n then
      ()
    else
      (row.(i) <- create_array 3 0;
       malloc_1d (i+1) n row) in
  let rec malloc_2d i n =
    if i = n then
      ()
    else
      (let row = create_array size (create_array 3 0) in
       malloc_1d 0 size row;
       image.(i) <- row;
       malloc_2d (i+1) n) in
  malloc_2d 0 size
in


let rec compute_pixel i j =
  let c = complex_mat.(i).(j) in
  let rec compute_pixel_loop n x c =
    if n = 0 then
      0
    else
      let circ_sqr = norm_sqr x in
      if circ_sqr >= 4.0 then
        let t0 = (float_of_int n) /. (float_of_int limit) in
        let t1 = (float_of_int 255) *. t0 in
        (int_of_float t1) + 0
      else
        let t0 = cmul x x in
        let t1 = cadd t0 c in
        compute_pixel_loop (n-1) t1 c in
  compute_pixel_loop limit (0.0, 0.0) c
in


let rec compute_image _ =
  let rec compute_image_loop i j n =
    if i = n then
      if j = n then
        ()
      else
        (set_pixel image.(i).(j) (compute_pixel i j);
         compute_image_loop i (j+1) n)
    else
      if j = n then
        compute_image_loop (i+1) 0 n
      else
        (set_pixel image.(i).(j) (compute_pixel i j);
         compute_image_loop i (j+1) n) in
  compute_image_loop 0 0 size
in


let rec print_pixel rgb =
  print_int rgb.(0);
  print_char 32;
  print_int rgb.(1);
  print_char 32;
  print_int rgb.(2);
  print_char 10
in


let rec print_image _ =
  let rec print_image_loop i j n =
    if i = n then
      if j = n then
        ()
      else
        (print_pixel image.(i).(j);
         print_image_loop i (j+1) n)
    else
      if j = n then
        print_image_loop (i+1) 0 n
      else
        (print_pixel image.(i).(j);
         print_image_loop i (j+1) n) in
  print_image_loop 0 0 size
in


let rec write_ppm_header _ =
  (
    print_char 80; (* 'P' *)
    print_char (48 + 3); (* +6 if binary *) (* 48 = '0' *)
    print_char 10;
    print_int size;
    print_char 32;
    print_int size;
    print_char 32;
    print_int 255;
    print_char 10
  )
in


let rec main _ =
  init_complex_mat ();
  init_image ();
  write_ppm_header ();
  compute_image ();
  print_image ()
in

main ()
