open kNormal

let find x env = try M.find x env with Not_found -> x

let rec alpha_conv env = function
  | Unit -> Unit
  | Int(i) -> Int(i)
  | Float(f) -> Float(f)
  | Neg(x) -> Neg(find x env)
  | Itof(x) -> Itof(find x env)
  | In(x) -> In(find x env)
  | Fin(x) -> Fin(find x env)
  | Out(x) -> Out(find x env)
  | Add(x, y) -> Add(find x env, find y env)
  | Sub(x, y) -> Sub(find x env, find y env)
  | Mul(x, y) -> Mul(find x env, find y env)
  | Div(x, y) -> Div(find x env, find y env)
  | FNeg(x) -> FNeg(find x env)
  | Ftoi(x) -> Ftoi(find x env)
  | FSqrt(x) -> FSqrt(find x env)
  | Floor(x) -> Floor(find x env)
  | FAdd(x, y) -> FAdd(find x env, find y env)
  | FSub(x, y) -> FSub(find x env, find y env)
  | FMul(x, y) -> FMul(find x env, find y env)
  | FDiv(x, y) -> FDiv(find x env, find y env)
  | IfEq(x, y, e1, e2) ->
     IfEq(find x env, find y env, alpha_conv env e1, alpha_conv env e2)
  | IfLE(x, y, e1, e2) ->
     IfLE(find x env, find y env, alpha_conv env e1, alpha_conv env e2)
  | IfLt(x, y, e1, e2) ->
     IfLt(find x env, find y env, alpha_conv env e1, alpha_conv env e2)
  | Let ((x,t),e1,e2) ->
     let x' = Id.genid x in
     Let((x',t), alpha_conv env e1, alpha_conv (M.add x x' env) e2)
  | Var(x) -> Var(find x env)
  | LetRec({ name = (x,t); args = yts; body = e1 },e2) ->
     let env = M.add x (Id.genid x) env in
     let ys = List.map fst yts in
     let env' = M.add_list2 ys (List.map Id.genid ys) env in
     LetRec({ name = (find x env, t);
              args = List.map (fun (y,t) -> (find y env',t)) yts;
              body = alpha_conv env' e1},
            alpha_conv env e2)